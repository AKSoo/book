.. _config:

Everything you ever wanted to configure
---------------------------------------

Back in section :ref:`text2git`, we already learned that there
are dataset configurations, and that these configurations can
be modified, for example with the ``-c text2git`` option.
This option applies a configuration template to store text
files in :term:`Git` instead of :term:`Git-annex`, and thereby
modifies the DataLad dataset's default configuration to store
every file in Git-annex.

The lecture today focuses entirely on the topic of configurations,
and aims to equip everyone with the basics to configure
their general and dataset specific setup to their needs.
This is not only a handy way to tune a dataset to one's
wishes, but also helpful to understand potential differences in
command execution and file handling between two users,
computers, or datasets.

"First of all, when we talk about configurations, we have
to differentiate between different scopes of configuration,
and different tools the configuration belongs or applies to",
our lecturer starts. "In DataLad datasets, different tools can
have a configuration: :term:`Git`, :term:`Git-annex`, and
obviously DataLad itself. Because these tools are all
combined by DataLad to help you manage your data,
it is important to understand how the configuration of one
software is used by or influences a second tool, or the overall
dataset performance."

"Oh crap, one of these theoretical lectures again" mourns a
student from the row behind you. Personally, you'd also
be much more excited
about any hands-on lecture filled with commands. But the
recent lecture about :term:`Git-annex` and the :term:`object-tree`
was surprisingly captivating, so you're actually looking forward to today.
"Shht! I want to hear this!", you shush him with a wink.

"We will start by looking into the very first configuration
you did, already before the course started: The *global*
Git configuration." the lecturer says.

At one point in time, you likely followed instructions such as
in :ref:`install` and configured your
*Git identity* with the commands::

   git config --global --add user.name Bob McBobFace
   git config --global --add user.email bob@example.com

"What the above commands do is very simple: They search for
a specific configuration file, and set the variables specified
in the command -- in this case user name and user email address
-- to the values provided with the command." she explains.

"This general procedure, specifying a value for a configuration
variable in a configuration file, is how you can configure the
different tools to your needs. The configuration, therefore,
is really easy. Even if you are only used to ticking boxes
in the ``settings`` tab of a software tool so far, it's intuitive
to understand how a configuration file in principle works and also
how to use it. The only piece of information you will need
are the necessary files, or the command that writes to them and
the available options for configuration, that's it. And what's
really cool is that all tools we'll be looking at -- Git, Git-annex,
and DataLad -- can be configured using the :command:`git config`
command [#f1]_.
Now, let's learn *how* to configure settings, but also
*understand* them."

"This seems easy enough", you think. Let's see what types of
configurations there are.

Git config files
^^^^^^^^^^^^^^^^

The user name and email configuration
is a *user-specific* configuration (called *global*
configuration by Git), and therefore applies to your user account.
Where ever on your computer *you* run a Git, Git-annex, or DataLad
command this global configuration will
associate the name and email address you supplied in
the :command:`git config` commands above with this action.
For example, whenever you
``datalad save``, the information in this file is used for the
history entry about commit author and email.

Apart from *global* Git configurations, there are also *system-wide* [#f2]_
and *repository* configurations. Each of these configurations
resides in its own file. The global configuration is stored in a file called
``.gitconfig`` in your home directory. Among
your name and email address, this file can store general
per-user configurations, such as a default editor [#f3]_, or highlighting
options.

The *repository-specific* configurations apply to each individual
repository. Their scope is more limited than the *global*
configuration (namely to a single repository), but it can overrule global
configurations: The more specific the scope of a configuration file is, the more
important it is, and the variables in the more specific configuration
will take precedence over variables in less specific configuration files.
One could for example have :term:`vim` configured to be the default editor
on a global scope, but could overrule this by setting the editor to nano
in a given repository. For this reason, the repository-specific configuration
does not reside in a file in your home directory, but in ``.git/config``
within every Git repository (and thus DataLad dataset).

Thus, there are three different scopes of Git configuration, and each is defined
in a ``config`` file in a different location. The configurations will determine
how Git behaves. In principle, all of these files can configure
the same variables differently, but more specific scopes take precedence over broader
scopes. Conveniently, not only can DataLad and Git-annex be configured with
the same command as Git, but in many cases they will also use exactly the same
files as Git for their own configurations.

Let's find out how the repository-specific configuration file in the ``DataLad-101``
superdataset looks like:

.. runrecord:: _examples/DL-101-125-101
   :language: console
   :workdir: dl-101/DataLad-101

   $ cat .git/config

This file consists of so called "sections" with the section names
in square brackets (e.g. ``core``). Occasionally, a section can have
subsections: This is indicated by subsection names in
quotation marks after the section name. For example, ``roommate`` is a subsection
of the section ``remote``.
Within each section, ``variable = value`` pairs specify configurations
for the given (sub)section.

The first section is called ``core`` -- as the name suggests,
this configures core Git functionality. There are
`many more <https://git-scm.com/docs/git-config#Documentation/git-config.txt-corefileMode>`_
configurations than the ones in this config file, but
they are related to Git, and less related or important to the configuration of
a DataLad dataset. We will use this section to showcase the anatomy of the
:command:`git config` command, however. If you would want to specifically
configure :term:`nano` to be the default editor in this dataset, you
can do it like this:

.. runrecord:: _examples/DL-101-125-102
   :language: console
   :workdir: dl-101/DataLad-101

   $ git config --local --add core.editor "nano"

The command consists of the base command :command:`git config`,
a specification of the scope of the configuration with the ``--local``
flag, a ``name`` specification consisting of section and key with the
notation ``section.variable`` (here: ``core.editor``), and finally the value
specification ``"nano"``.

Let's see what has changed:

.. runrecord:: _examples/DL-101-125-103
   :language: console
   :workdir: dl-101/DataLad-101
   :emphasize-lines: 7

   $ cat .git/config

With this additional line in your repositories Git configuration, nano will
be used as a default editor regardless of the configuration in your global
or system-wide configuration. Note that the flag ``--local`` applies the
configuration to your repository's ``.git/config`` file, whereas ``--global``
would apply it as a user specific configuration, and ``--system`` as a
system-wide configuration.
If you would want to change this existing line in your ``.git/config``
file, you would replace ``--add`` with ``--replace-all`` such as in::

   git config --local --replace-all core.editor "vim"

to configure :term:`vim` to be your default editor.

(Note that while being a good toy example, it is not a common thing to
configure repository-specific editors)

This example demonstrated the structure of a :command:`git config`
command. By specifying the ``name`` option with ``section.variable``
(or ``section.subsection.variable`` if there is a subsection), and
a value, one can configure Git, Git-annex, and DataLad.
*Most* of these configurations will be written to a ``config`` file
of Git, depending on the scope (local, global, system-wide)
specified in the command.

.. container:: toggle

   .. container:: header

       **Addition: If things go wrong**

   If something goes wrong during the :command:`git config` command,
   for example you end up having two keys of the same name because you
   added a key instead of replacing an existing one, you can use the
   ``--unset`` option to remove the line. Alternatively, you can also open
   the config file in an editor and remove or change sections by hand.


The only information you need, therefore, is the name of a section and
variable to configure, and the value you want to specify.

The configuration file inside of ``DataLad-101`` does not appear to be
intuitively understandable enough to confidently apply changes to them,
or identify necessary changes. And indeed, most of the sections and variables
or values in there are irrelevant for understanding the book, your dataset,
or DataLad, and can just be left as they are. The previous section merely served
to de-mystify the :command:`git config` command and the configuration files.
Nevertheless, it might be helpful to get an overview about the meaning of the
remaining sections in that file, and the following hidden section can give
you a glimpse of this.

.. container:: toggle

   .. container:: header

      **Addition: More on this config file**

   The second section of ``.git/config`` is a Git-annex configuration.
   As mentioned above, Git-annex will use the
   :term:`Git config file` for some of its configurations.
   For example, it lists the repository as a
   "version 5 repository", and gives the dataset its own Git-annex
   UUID. While the "annex-uuid" [#f4]_ looks like yet another cryptic
   random string of characters, you have seen a UUID like this before:
   A :command:`git annex whereis` displays information about where the
   annexed content in a dataset is with these UUIDs.
   This section also specifies the supported backends in this dataset.
   If you have read the hidden section in the section
   :ref:`symlink` you will recognize the name "MD5E". This is the
   hash function used to generate the annexed files keys and thus
   paths in the object tree. All backends specified in this file (it
   can be a list) can be used to hash your files.

   You may recognize third part of the configuration, the subsection
   ``"recordings/longnow"`` in the section ``submodule``.
   Clearly, this is a reference to the ``longnow`` podcasts
   we installed as a subdataset. The name *submodule* is Git
   terminology, and describes a Git repository inside of
   another Git repository -- just like
   the super- and subdataset principles you discovered in the
   section :ref:`nesting`. When you install a DataLad dataset
   as a subdataset, it gets *registered* in this file.
   For each subdataset, an individual submodule entry
   will store the information about the subdatasets
   ``--source`` or *origin* (the "url").
   Thus, every subdataset (and sub-subdataset, and so forth) in your dataset
   will be listed in this file.
   If you want, go back to section :ref:`installds` to see that the
   "url" is the same URL we installed the longnow dataset from, and
   go back to section :ref:`sharelocal1` to remind yourself of
   how installing a dataset with subdatasets looked and felt like.

   Another interesting part is the last section, "remote".
   Here we can find the :term:`sibling` "roommate" we defined
   in :ref:`sibling`. The term :term:`remote` is Git-terminology and is
   used to describe other repositories or DataLad datasets that the
   repository knows about and tracks.
   This file, therefore, is where DataLad *registered* the sibling
   with :command:`datalad siblings add`, and thanks to it you can
   collaborate with your room mate.
   Note the *path* given as a value to the ``url`` variable. If at any point
   either your superdataset or the remote moves on your file system,
   the association between the two datasets breaks -- this can be fixed by adjusting this
   path, and a demonstration of this is in section (Todo: link file system management).
   `fetch` contains a specification which parts of the repository are
   updated - in this case the everything (all of the branches).
   Lastly, the ``annex-ignore = false`` configuration allows Git-annex
   to query the remote when it tries to retrieve data from annexed content.

``.git/config`` versus other configuration files
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Within a Git repository, ``.git/config`` is not the only configuration file.
There are also ``.gitmodules`` and ``.gitattributes``, and in DataLad datasets
there also is a ``.datalad/config`` file.

One crucial aspect distinguishes the ``.git/config`` file from those other files:
*It will not be shared.* The reason for this is simple. This config file
lives in the ``.git`` directory of your repository, and this directory is not
version controlled


.. todo::

   * understand why there are .gitmodules files with the same information
     as in the .gitmodules section, and also redundancy to .gitattributes (the
     git annex backend. which files need to be modified to change a specific
     option?

   * .gitmodules is a configuration file that stores the mapping between
     the projects URL and the local subdirectory you've pulled it into.
     There will be an entry for each submodule (subdataset) in your dataset.
     This file is how other people that install your superdataset know where to get
     submodule projects from.

   * To change the backend, you should set it in ``.gitattributes``


Git-annex configurations
^^^^^^^^^^^^^^^^^^^^^^^^

"By now we have only seen this huge amount of configurations
in git configuration files! Are there other files, specifically created
by DataLad for example?"
you impatiently raise your arm and ask.

"DataLad adds a repository-specific configuration file as well",
you hear in response. "This file can be found in the ``.datalad``
directory. But before we go to DataLad-specific configuration files,
we'll need to look at Git-annex configurations. For example,
you surely all remember the ``text2git`` configuration template
we applied to ``DataLad-101``. Let's now see what exactly this
configuration template did and kook into
the file ``.gitattributes``." This file
lies right in the root of your superdataset:

.. runrecord:: _examples/DL-101-125-104
   :language: console
   :workdir: dl-101/DataLad-101

   $ cat .gitattributes

This looks neither spectacular nor pretty. There is one key word that
you recognize, though: MD5E. It's again a reference to the type of
key used by Git-annex to identify and store file content in the object-tree.

This ``annex.backend`` option indeed would be the place to change
the key type. TODO: how precisely?

But what is the rest? We'll start with the last row::

   * annex.largefiles=(not(mimetype=text/*))

Uhhh, cryptic. The lecturer explains:

"Git-annex will *annex*, that is: store in the object-tree,
anything it considers to be a "large file". By default, anything
in your dataset would be a "large file". However, in section
:ref:`symlink` I already mentioned that exceptions to this behavior
can be defined based on

#. file size

#. and/or path/pattern, and thus for example file extensions,
   or names, or file types (e.g. text files, as with the
   ``text2git`` configuration template).

"In ``.gitattributes``, you can define what a large file and what is not
by simply telling Git-annex by writing such rules."

What you can see in this ``.gitattribute`` file is a rule based on file types:
With ``mimetype=text/*)`` [#f5]_, the ``text2git`` configuration template
configured Git-annex to regard all files of type text **not** as a large file.
Thanks to this little line, your text files are not annexed, but stored
directly in Git.

todo; explain the * and **


"This is one way of configuring the ``annex.largefiles`` option -- using
file's MIME types as a specification. You could just as easily however also
specify paths or single file names."

To see an example of this, navigate into the longnow subdataset,
and view this dataset's ``.gitattributes`` file:

.. runrecord:: _examples/DL-101-125-105
   :language: console
   :workdir: dl-101/DataLad-101

   $ cd recordings/longnow
   $ cat .gitattributes

The relevant part is ``README.md annex.largefiles=nothing``
This instructs Git-annex to specifically not annex ``README.md``.


.. todo::

   are there other mimetypes? where does the name come from? what does
   the ``/*`` do?




.. runrecord:: _examples/DL-101-125-106
   :language: console
   :workdir: dl-101/DataLad-101

   $ cat .datalad/config

.. todo::

   find out what can be inside a datalad config file

This has been an intense lecture, you have to admit. One definite
take-away from it has been that you now know a second reason why the hidden
``.git`` and ``.datalad`` directory contents shouldn't be carelessly
tempered with -- they contain all of the repositories configurations.

But you now also know how to modify these configurations with enough
care and background knowledge such that nothing should go wrong once you
want to work with and change them. Slowly, you realize with pride,
you're more and more becoming a DataLad power-user.


TODO: environment variables. Environment variables take precedence over configuration file
settings



.. rubric:: Footnotes

.. [#f1] As an alternative to a ``git config`` command, you could also run configuration
         templates or procedures (todo: link) that apply predefined configurations or in some cases even
         add the information to the configuration file by hand and save it using an editor of your choice.

.. [#f2] The third scope of a Git configuration are the system wide configurations.
         These are stored (if they exist) in ``/etc/gitconfig`` and contain settings that would
         apply to every user on the computer you are using. These configurations
         are not relevant for DataLad-101, and we will thus skip them. You can
         read more about Gits configurations and different files
         `here <https://git-scm.com/docs/git-config>`_.

.. [#f3] If your default editor is :term:`vim` and you do not like this, now can be the time
         to change it! Chose either of two options:

         1) Open up the file with an editor for your choice (e.g.
         `nano <https://www.howtogeek.com/howto/42980/the-beginners-guide-to-nano-the-linux-command-line-text-editor/>`_)::

             nano ~/.gitconfig

         and either paste the following configuration or edit it if it already exists::

            [core]
                editor = nano


         2) run the following command, but exchange ``nano`` with an editor of your choice::

             git config --global core.editor "nano"

.. [#f4] A UUID is a universally unique identifier -- a 128-bit number
         that unambiguously identifies information.

.. [#f5] When opening any file on a UNIX system, the file does not need to have a file
         extension (such as ``.txt``, ``.pdf``, ``.jpg``) for the operating system to know
         how to open or use this file (in contrast to Windows, which does not know how to
         open a file without an extension). To do this, Unix systems rely on a file's
         MIME type -- an information about a file's content. A ``.txt`` file for example
         has MIME type ``text/plain`` as does a bash script (``.sh``), a Python
         script has MIME type ``text/x-python``, a ``.jpg`` file is ``image/jpg``, and
         a ``.pdf`` file has MIME type ``application/pdf``. You can find out the MIME type
         of a file by running::

            file --mime-type path/to/file